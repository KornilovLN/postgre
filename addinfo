## Вы можете заменить значения переменных окружения на свои собственные.
<br>В вашем случае, вы можете заменить admin на Ivanov, а admin_password на Q45!79fDb.
<br>с помощью команды docker-compose up -d.
<br>вы можете изменить название базы данных main_db на Common-DB-Postgres.
<br>Для этого нужно обновить значение переменной окружения POSTGRES_DB
<br>в файле docker-compose.yml.
<br>Вот как будет выглядеть обновленный файл:
```
version: '3.8'

services:
  postgres:
    image: postgres:latest
    container_name: postgres
    environment:
      POSTGRES_USER: Ivanov
      POSTGRES_PASSWORD: Q45!79fDb
      POSTGRES_DB: Common-DB-Postgres
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    networks:
      - pgnetwork

volumes:
  pgdata:

networks:
  pgnetwork:
```

#### Теперь при запуске контейнера будет создана база данных с именем Common-DB-Postgres.
<br>данные, сохраненные в томе, будут надежно сохранены и могут быть использованы повторно
<br>при переустановке базы данных или запуске нового контейнера.
<br>В вашем docker-compose.yml файле вы используете именованный том pgdata,
<br>который монтируется в директорию /var/lib/postgresql/data внутри контейнера. Это стандартная практика для сохранения данных PostgreSQL.

**_Вот как это работает:_**

- Создание и использование тома:
    Когда вы запускаете контейнер с помощью docker-compose up -d,
    Docker создает именованный том pgdata, если он еще не существует,
    и монтирует его в указанную директорию внутри контейнера.

- Сохранение данных: 
    Все данные, которые PostgreSQL сохраняет в /var/lib/postgresql/data,
    будут фактически сохранены в томе pgdata на хосте.

- Переустановка контейнера:
    Если вы остановите и удалите контейнер,
    данные в томе pgdata останутся нетронутыми.
    Когда вы создадите новый контейнер и снова смонтируете этот том,
    PostgreSQL сможет продолжить работу с теми же данными.

**_Пример переустановки контейнера:_**
```
# Остановить и удалить текущий контейнер
docker-compose down

# Запустить новый контейнер с тем же томом
docker-compose up -d
```

При этом данные в томе pgdata сохранятся и будут доступны новому контейнеру.

**_Пример docker-compose.yml с именованным томом:_**
```
version: '3.8'

services:
  postgres:
    image: postgres:latest
    container_name: postgres
    environment:
      POSTGRES_USER: Ivanov
      POSTGRES_PASSWORD: Q45!79fDb
      POSTGRES_DB: Common-DB-Postgres
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    networks:
      - pgnetwork

volumes:
  pgdata:

networks:
  pgnetwork:
```

**_Проверка данных после переустановки_**
<br>После переустановки контейнера вы можете
<br>подключиться к базе данных и убедиться, что данные сохранились:
```
# Подключиться к контейнеру
docker exec -it postgres psql -U Ivanov -d Common-DB-Postgres

# Выполнить SQL-запрос для проверки данных
SELECT * FROM some_table;
```
```
Таким образом, использование именованных томов в Docker
обеспечивает надежное сохранение данных и позволяет
легко переустанавливать контейнеры без потери данных.
```

**_Вы можете обращаться к базе данных PostgreSQL,_**
<br>размещенной на удаленном сервере, из разных мест сети
<br>и с использованием различных менеджеров баз данных,
<br>таких как Virtuoso, pgAdmin, DBeaver и другие.

**_Для этого нужно убедиться, что:_**
* Контейнер PostgreSQL настроен для прослушивания внешних подключений.
* Брандмауэр и сетевые настройки сервера позволяют внешние подключения к порту 5432.
* Конфигурация PostgreSQL разрешает подключения от удаленных клиентов.

**_Шаги для настройки удаленного доступа:_**
<br>Настройка PostgreSQL для прослушивания внешних подключений:
* В файле postgresql.conf нужно изменить параметр listen_addresses на '*',
  <br>чтобы PostgreSQL слушал на всех интерфейсах.

**_Если вы используете Docker, вы можете добавить это в ваш init.sql_**
или создать отдельный конфигурационный файл и смонтировать его в контейнер.
```
-- init.sql
ALTER SYSTEM SET listen_addresses = '*';
```

Настройка доступа для удаленных клиентов:

В файле pg_hba.conf нужно добавить записи 
для разрешения подключений от удаленных клиентов.
Например, чтобы разрешить доступ всем клиентам из сети 0.0.0.0/0:
```
host    all             all             0.0.0.0/0               md5
```

Если вы используете Docker, вы можете смонтировать этот файл в контейнер.

Обновление Docker Compose файла:
Убедитесь, что порт 5432 открыт для внешних подключений в вашем docker-compose.yml:
```
version: '3.8'

services:
  postgres:
    image: postgres:latest
    container_name: postgres
    environment:
      POSTGRES_USER: Ivanov
      POSTGRES_PASSWORD: Q45!79fDb
      POSTGRES_DB: Common-DB-Postgres
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    networks:
      - pgnetwork

volumes:
  pgdata:

networks:
  pgnetwork:
```

Перезапуск контейнера:
После внесения изменений перезапустите контейнер:
```
docker-compose down
docker-compose up -d
```

Настройка брандмауэра и сетевых правил:
Убедитесь, что брандмауэр и сетевые настройки вашего сервера
позволяют входящие подключения к порту 5432.
Например, для настройки брандмауэра на Ubuntu:
```
sudo ufw allow 5432/tcp
```

Подключение к базе данных из удаленного клиента
Теперь вы можете подключиться к вашей базе данных PostgreSQL,
размещенной на <www.path.to.db>:5432,
используя любой менеджер баз данных.
Например, для подключения с помощью psql:
```
psql -h www.path.to.db -p 5432 -U Ivanov -d Common-DB-Postgres
```

Для подключения с помощью других менеджеров баз данных,
таких как pgAdmin, DBeaver или Virtuoso,
используйте соответствующие параметры подключения,
указав хост, порт, имя пользователя и пароль.

Примечание по безопасности
Разрешение подключений от всех IP-адресов (0.0.0.0/0) может быть небезопасным.
Рекомендуется ограничить доступ только доверенными IP-адресами
или использовать VPN для безопасного подключения к базе данных.